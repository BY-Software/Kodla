<resources>
    <string name="app_name">Kodla</string>

    <string name="text_inside_circle_button_text_normal">Text Inside Circle Button(Normal)</string>
    <string name="text_inside_circle_button_text_highlighted">Text Inside Circle Button(Highlighted)</string>
    <string name="text_inside_circle_button_text_unable">Text Inside Circle Button(Unable)</string>

    <string name="text_outside_circle_button_text_normal">Text Outside Circle Button(Normal)</string>
    <string name="text_outside_circle_button_text_highlighted">Text Outside Circle Button(Highlighted)</string>
    <string name="text_outside_circle_button_text_unable">Text Outside Circle Button(Unable)</string>

    <string name="text_ham_button_text_normal">Ham Button Text(Normal)</string>
    <string name="text_ham_button_text_highlighted">Ham Button Text(Highlighted)</string>
    <string name="text_ham_button_text_unable">Ham Button Text(Unable)</string>
    <string name="text_ham_button_sub_text_normal">Ham Button Sub Text(Normal)</string>
    <string name="text_ham_button_sub_text_highlighted">Ham Button Sub Text(Highlighted)</string>
    <string name="text_ham_button_sub_text_unable">Ham Button Sub Text(Unable)</string>

    <string name="main_fragment">To learn new information, please press the button and choose a topic.</string>

    <string name="java_tip_1">If a program is returning a collection which does not have any value, make sure an Empty collection is returned rather than Null elements. This saves a lot of “if else” testing on Null Elements.</string>
    <string name="java_tip_2">If two Strings are concatenated using “+” operator in a “for” loop, then it creates a new String Object, every time. This causes wastage of memory and increases performance time. Also, while instantiating a String Object, constructors should be avoided and instantiation should happen directly</string>
    <string name="java_tip_3">Developers often find it difficult to decide if they should go for Array type data structure of ArrayList type. They both have their strengths and weaknesses. The choice really depends on the requirements.</string>
    <string name="java_tip_4">Java offers a Library method called indexOf(). This method is used with String Object and it returns the position of index of desired string. If the string is not found then -1 is returned.</string>
    <string name="java_tip_5">In order to read from a file and write to a file, Java offers FileInputStream and FileOutputStream Classes. FileInputStream’s constructor accepts filepath of Input File as argument and creates File Input Stream. Similarly, FileOutputStream’s constructor accepts filepath of Output File as argument and creates File Output Stream.After the file handling is done, it’s important to “close” the streams.</string>

    <string name="github_tip_1">git status: Check the status of your repository. See which files are inside it, which changes still need to be committed, and which branch of the repository you’re currently working on.</string>
    <string name="github_tip_2">git add: This does not add new files to your repository. Instead, it brings new files to Git’s attention. After you add files, they’re included in Git’s “snapshots” of the repository.</string>
    <string name="github_tip_3">git commit: Git’s most important command. After you make any sort of change, you input this in order to take a “snapshot” of the repository. Usually it goes git commit -m “Message here.” The -m indicates that the following section of the command should be read as a message.</string>
    <string name="github_tip_4">git push: If you’re working on your local computer, and want your commits to be visible online on GitHub as well, you “push” the changes up to GitHub with this command.</string>
    <string name="github_tip_5">git pull: If you’re working on your local computer and want the most up-to-date version of your repository to work with, you “pull” the changes down from GitHub with this command.</string>

    <string name="kotlin_tip_1">Kotlin\'s custom getters and setters use the structure of a model, but specify custom behavior to get and set the fields. When using custom models for certain frameworks, such as the Parse SDK, you are fetching values that are not actually local variables in the class, but are stored and retrieved in some custom way, such as from JSON.</string>
    <string name="kotlin_tip_2">Lambdas reduce the overall lines of code in a source file and allow for functional programming. While lambdas are currently possible with Android, Kotlin takes them a step further by ensuring you don\'t have to deal with Retrolambda or changing the way your build is configured.</string>
    <string name="kotlin_tip_3">Data classes simplify classes, adding equals(), hashCode(), copy(), and toString() methods automatically. They clarify the intention of the model and what should go in it, separating pure data from business logic.</string>
    <string name="kotlin_tip_4">Collections are dealt with quite often when working with an API. More often then not, you want to filter or modify the contents of that collection. By using Kotlin\'s collection filtering, adding clarity and making your code more succinct.</string>
    <string name="kotlin_tip_5">Optional parameters make method calls more flexible without having to pass null or a default value. This is especially useful when defining animations.</string>

    <string name="js_tip_1">If two operands are of the same type and value, then === produces true and !== produces false.</string>
    <string name="js_tip_2">Place scripts at the bottom of your page.</string>
    <string name="js_tip_3">Don\'t always reach for your handy-dandy "for" statement when you need to loop through an array or object. Be creative and find the quickest solution for the job at hand.</string>
    <string name="js_tip_4">By reducing your global footprint to a single name, you significantly reduce the chance of bad interactions with other applications, widgets, or libraries.</string>
    <string name="js_tip_5">Always compensate for when JavaScript is disabled. It might be tempting to think, "The majority of my viewers have JavaScript enabled, so I won't worry about it." However, this would be a huge mistake.</string>

    <string name="swift_tip_1">Method swizzling is a technique that substitutes one method implementation for another. Swift optimizes code to call direct memory addresses instead of looking up the method location at runtime as in Objective-C. So by default swizzling doesn’t work in Swift classes.</string>
    <string name="swift_tip_2">You should always be using the appropriate access control modifier to encapsulate code. Good encapsulation helps us understand how pieces of code interact without having to remember our thought process or ask the developer who wrote it.</string>
    <string name="swift_tip_3">An optional property is a property that can have a valid value or have no value (nil). We can implicitly unwrap an optional by following the optional\'s name with an exclamation point, as in optionalProperty!. This is generally something you want to avoid, as hinted at by the exclamation point meaning “danger!”</string>
    <string name="swift_tip_4">Objective-C used C primitives for numbers, and the Foundation Objective-C API provided the NSNumber type to box and unbox primitives. We had code that looked like [array addObject:@(intPrimitive)] and [array[0] intValue] when we needed to go back and forth between primitives and object types. Swift doesn’t have this awkward mechanism. Instead, we can actually add Int / Float / AnyObject values to Swift dictionaries and arrays.</string>
    <string name="swift_tip_5">With Swift, function arguments can now have default values. These default arguments reduce clutter. If the callee of the function chooses to use the default values, the function call is shorter because the default arguments can be omitted.</string>

    <string name="android_tip_1">To reinforce responsiveness, you should shift long-running tasks (e.g. network or database operations, complex calculations) from an app\'s main thread to a separate background thread. The most effective way to accomplish this task is at a class level. You can use AsyncTask class or IntentService class to organize background work. Once you have implemented an IntentService, it starts when needed and handles requests (Intents) using a worker thread.</string>
    <string name="android_tip_2">Displaying data is not immediate, although you can fasten it by using CursorLoader objects, which allows not to distract Activity from interacting with a user while query is processing in the background.  Armed with this object your app would initiate a separate background thread for each ContentProvider query and return results to Activity from which the query was called only when the query is finished.</string>
    <string name="android_tip_3">When creating UI sticking solely to basic features of layout managers, you risk to create memory abusing apps with annoying delays in the UI. The first step to implementation of a smooth, memory caring UI is to search your application for potential layout performance bottlenecks with Hierarchy Viewer tool included into Android SDK: sdk/tools/.</string>
    <string name="android_tip_4">Lint: It scans application sources for possible bugs along with view hierarchy optimizations.</string>
    <string name="android_tip_5">Make sure to unregister as GPS location updates can continue even after onPause(). When all applications unregister, users can enable GPS in Settings without blowing the battery budget.</string>
</resources>
